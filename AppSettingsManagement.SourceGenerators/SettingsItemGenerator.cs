using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace AppSettingsManagement.Generators
{

    [Generator(LanguageNames.CSharp)]
    public class SettingsItemSourceGenerator : ISourceGenerator
    {
        public SettingsItemSourceGenerator()
        {
#if DEBUG
            if (!Debugger.IsAttached)
            {
                //Debugger.Launch();
            }
#endif
        }
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SettingsContainerSyntaxReceiver());
        }

        string GenerateSettingItem(AttributeSyntax attribute)
        {
            var arguments = attribute.ArgumentList.Arguments;
            
            if (arguments.Count < 2) return "";

            string propertyType = arguments[0].Expression.ToString();
            propertyType = propertyType.Substring("typeof(".Length, propertyType.Length - 1 - "typeof(".Length); // Remove typeof()

            string propertyName = arguments[1].Expression.ToString().Trim('"');
            string defaultValue = "";
            string converterType = ""; // To be implemented
            if(arguments.Count > 2)
            {
                defaultValue = $", {arguments[2].Expression.ToString().Trim()}";
            }

            string nullable = string.IsNullOrEmpty(defaultValue) ? "?" : "";

            return
$@"        public {propertyType}{nullable} {propertyName}
        {{
            get => GetValue<{propertyType}{nullable}>(nameof({propertyName}){defaultValue});
            set => SetValue<{propertyType}>(nameof({propertyName}), value, ref {propertyName}Changed);
        }}

        public event AppSettingsManagement.SettingChangedEventHandler? {propertyName}Changed;

";
        }

        string GenerateSettingsContainer(AttributeSyntax attribute)
        {
            return "";
        }

        string GenerateSettingsArray(AttributeSyntax attribute)
        {
            return "";
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var syntaxReceiver = (SettingsContainerSyntaxReceiver)context.SyntaxReceiver;

            foreach (var (classDeclaration, constructorAttributes) in syntaxReceiver.SettingsContainerConstructorAttributes)
            {
                INamedTypeSymbol classSymbol = 
                    (INamedTypeSymbol)context.Compilation
                    .GetSemanticModel(classDeclaration.SyntaxTree)
                    .GetDeclaredSymbol(classDeclaration);

                string className = classSymbol.Name;
                string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

                var membersBuilder = new StringBuilder();
                foreach (var attributeInfo in constructorAttributes)
                {
                    string attributeName = attributeInfo.Name.ToString();

                    string memberGenerated = "";
                    if (attributeName == "SettingItem")
                        memberGenerated = GenerateSettingItem(attributeInfo);
                    else if (attributeName == "SettingsContainer")
                        memberGenerated = GenerateSettingsContainer(attributeInfo);

                    membersBuilder.Append($"{memberGenerated}\n");
                }

                var source = $@"// <auto-generated/>
#pragma warning disable
#nullable enable
namespace {namespaceName}
{{
    partial class {className}
    {{
{membersBuilder}
    }}
}}
";
                context.AddSource($"{className}_SettingsContainerMembersGenerated", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    internal class SettingsContainerSyntaxReceiver : ISyntaxReceiver
    {
        public List<(ClassDeclarationSyntax Node, List<AttributeSyntax> Attributes)> SettingsContainerConstructorAttributes { get; } = new List<(ClassDeclarationSyntax Node, List<AttributeSyntax> Attributes)>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax)
            {
                // Check if the class inherits SettingsContainer
                bool isSettingsContainer = 
                    classDeclarationSyntax?.BaseList?.Types
                    .Where(type =>
                        (type.Type as IdentifierNameSyntax)?
                        .Identifier
                        .Text == "SettingsContainer"
                        )
                    .Any() ?? false;

                if (!isSettingsContainer) return;

                // Find attributes of the constructor
                var constructors = classDeclarationSyntax.DescendantNodes().OfType<ConstructorDeclarationSyntax>();
                foreach (var constructor in constructors)
                {
                    var attributes = new List<AttributeSyntax>();

                    foreach (var attributeList in constructor.AttributeLists)
                    {
                        foreach (var attribute in attributeList.Attributes)
                        {
                            string attributeName = attribute.Name.ToString();
                            if (attributeName.Contains("SettingItem") || attributeName.Contains("SettingsContainer"))
                            {
                                attributes.Add(attribute);
                            }
                        }
                    }

                    if (attributes.Any())
                    {
                        SettingsContainerConstructorAttributes.Add((classDeclarationSyntax, attributes));
                    }
                }
            }
        }
    }

}
