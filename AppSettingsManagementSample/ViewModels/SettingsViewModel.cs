using AppSettingsManagement;
using AppSettingsManagementSample.Services;
using CommunityToolkit.Mvvm.ComponentModel;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.ApplicationModel.Activation;

namespace AppSettingsManagementSample.ViewModels;


// TODO: autogenerate MVVM bindings
// Enhancement: build a separate WeakEventManager? use reflection?
/// <summary>
/// Autogenerated
/// </summary>
partial class SettingsViewModel
{
    [GeneratedCode("AppSettingsManagement", "alpha")]
    private ReadOnlyDictionary<string, SettingChangedEventHandler> __settingChangedEventHandlers = null!;

    /// <summary>
    /// This should be called in the constructor. Initialize view model and register events for updating view model when settings are changed.
    /// </summary>
    [GeneratedCode("AppSettingsManagement", "alpha")]
    private void InitializeSettings()
    {
        //Note: capture of _settingsService (or any class member) holds a reference to this class and, hence, prevents garbage collection
        SettingsService container = _settingsService;// Avoid capture of class member _settingsService in event handlers
        WeakReference<SettingsViewModel> weakref = new(this);
        Dictionary<string, SettingChangedEventHandler> handlers = new();

        // Generate: TestStringChanged
        SettingChangedEventHandler testStringChangedHandler = (sender, e) =>
        {
            if (weakref.TryGetTarget(out var target))
                target.TestString = container.TestString;
        };
        container.TestStringChanged += testStringChangedHandler;
        handlers[nameof(container.TestStringChanged)] = testStringChangedHandler;

        // Freeze event handlers dictionary
        __settingChangedEventHandlers = new(handlers);

        // Subscribe to setting changed event to update view model
        PropertyChanged += (object? sender, PropertyChangedEventArgs e) =>
        {
            if (e.PropertyName == nameof(TestString))
                _settingsService.TestString = TestString;
            //else if ...
        };
    }

    /// <summary>
    /// This should be called in the destructor. Unregister events for updating view model when settings are changed.
    /// </summary>
    [GeneratedCode("AppSettingsManagement", "alpha")]
    private void RemoveSettingsChagnedHandlers()
    {
        _settingsService.TestStringChanged -= __settingChangedEventHandlers[nameof(_settingsService.TestStringChanged)];
    }
}


internal partial class SettingsViewModel : ObservableObject
{
    [SettingsProvider]
    private readonly SettingsService _settingsService;

    public SettingsViewModel(SettingsService settingsService)
    {
        _settingsService = settingsService;
        InitializeSettings();
    }

    ~SettingsViewModel()
    {
        RemoveSettingsChagnedHandlers();
    }

    // Bind to settings service
    [BindToSetting(Path = nameof(SettingsService.IntList))]
    public ObservableCollection<int> TestList { get; private set; } = null!; // Will be initialized by generated code

    [ObservableProperty]
    [BindToSetting(Path = nameof(SettingsService.TestString))]
    string? testString;

}
