using AppSettingsManagement;
using AppSettingsManagement.Mvvm;
using AppSettingsManagementSample.Services;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using Windows.ApplicationModel.Activation;

namespace AppSettingsManagementSample.ViewModels;


// TODO: autogenerate MVVM bindings
// Enhancement: build a separate WeakEventManager? use reflection?
/// <summary>
/// Autogenerated
/// </summary>
partial class SettingsViewModel
{
    [GeneratedCode("AppSettingsManagement", "alpha")]
    SettingsContainer ISettingsViewModel.SettingsContainer => _settingsService;

    [GeneratedCode("AppSettingsManagement", "alpha")]
    Dictionary<string, SettingChangedEventHandler> ISettingsViewModel.SettingChangedEventHandlers { get; } = new();

    /// <inheritdoc/>
    [GeneratedCode("AppSettingsManagement", "alpha")]
    void ISettingsViewModel.InitializeSettings()
    {
        //Note: capture of _settingsService (or any class member) holds a reference to this class and, hence, prevents garbage collection
        SettingsService container = _settingsService;// Avoid capture of class member _settingsService in event handlers
        WeakReference<SettingsViewModel> weakref = new(this);
        Dictionary<string, SettingChangedEventHandler> handlers = ((ISettingsViewModel)this).SettingChangedEventHandlers;

        // Generate: TestStringChanged
        TestString = container.TestString;
        SettingChangedEventHandler testStringChangedHandler = (sender, e) =>
        {
            if (weakref.TryGetTarget(out var target))
                target.TestString = container.TestString;
        };
        container.TestStringChanged += testStringChangedHandler;
        handlers[nameof(SettingsService.TestString)] = testStringChangedHandler;

        // Generate: TestStringChanged
        Username = container.ActiveAccount.Username;
        SettingChangedEventHandler usernameChangedHandler = (sender, e) =>
        {
            if (weakref.TryGetTarget(out var target))
                target.Username = container.ActiveAccount.Username;
        };
        container.ActiveAccount.UsernameChanged += usernameChangedHandler;
        handlers[$"{nameof(SettingsService.ActiveAccount)}/{nameof(SettingsService.ActiveAccount.Username)}"] = usernameChangedHandler;

        // Generate: TestListChanged
        TestList = container.IntList;

        // Subscribe to setting changed event to update view model
        PropertyChanged += ((ISettingsViewModel)this).SettingsViewModelPropertyChangedCallback;
    }

    /// <inheritdoc/>
    [GeneratedCode("AppSettingsManagement", "alpha")]
    void ISettingsViewModel.SettingsViewModelPropertyChangedCallback(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(TestString))
            _settingsService.TestString = TestString;
        else if (e.PropertyName == nameof(Username))
            _settingsService.ActiveAccount.Username = Username;
    }

    /// <inheritdoc/>
    [GeneratedCode("AppSettingsManagement", "alpha")]
    void ISettingsViewModel.RemoveSettingsChagnedHandlers()
    {
        Dictionary<string, SettingChangedEventHandler> handlers = ((ISettingsViewModel)this).SettingChangedEventHandlers;
        _settingsService.TestStringChanged -= handlers[nameof(SettingsService.TestString)]; // Use the path specified in BindToSettingAttribute
        _settingsService.ActiveAccount.UsernameChanged -= handlers[$"{nameof(SettingsService.ActiveAccount)}/{nameof(SettingsService.ActiveAccount.Username)}"];
    }
}


internal partial class SettingsViewModel : ObservableObject, ISettingsViewModel
{
    [SettingsProvider]
    private readonly SettingsService _settingsService;

    public SettingsViewModel(SettingsService settingsService)
    {
        _settingsService = settingsService;
        ((ISettingsViewModel)this).InitializeSettings();
    }

    ~SettingsViewModel()
    {
        ((ISettingsViewModel)this).RemoveSettingsChagnedHandlers();
    }

    // Test: Bind to a single value
    [ObservableProperty]
    [BindToSetting(Path = nameof(SettingsService.TestString))]
    string? testString;

    // Test: Bind to an item in a subcontainer
    [ObservableProperty]
    [BindToSetting(Path = $"{nameof(SettingsService.ActiveAccount)}/{nameof(SettingsService.ActiveAccount.Username)}")]
    string username = null!; // Will be initialized by generated code, should not be declared as nullable because it will be bound to a non-nullable setting item.

    // Test: Bind to settings service for collection
    [BindToSetting(Path = nameof(SettingsService.IntList))]
    public ObservableCollection<int> TestList { get; private set; } = null!; // Will be initialized by generated code

    [RelayCommand]
    void AddItem()
    {
        TestList.Add(TestList.Count);
        Console.WriteLine();
    }

    [RelayCommand]
    void DeleteItem(int index)
    {
        TestList.RemoveAt(index);
    }
}
